[  
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by the NetEscapades.EnumGenerators source generator
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

#nullable enable

#if NETESCAPADES_ENUMGENERATORS_EMBED_ATTRIBUTES
namespace NetEscapades.EnumGenerators
{
    /// <summary>
    /// Add to enums to indicate that extension methods should be generated for the type
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Enum)]
    [global::System.Diagnostics.Conditional("NETESCAPADES_ENUMGENERATORS_USAGES")]
#if NET5_0_OR_GREATER
    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage(Justification = "Generated by the NetEscapades.EnumGenerators source generator.")]
#else
    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
#endif
    public class EnumExtensionsAttribute : global::System.Attribute
    {
        /// <summary>
        /// The namespace to generate the extension class.
        /// If not provided, the namespace of the enum will be used
        /// </summary>
        public string? ExtensionClassNamespace { get; set; }

        /// <summary>
        /// The name to use for the extension class.
        /// If not provided, the enum name with "Extensions" will be used.
        /// For example for an Enum called StatusCodes, the default name
        /// will be StatusCodesExtensions
        /// </summary>
        public string? ExtensionClassName { get; set; }

        /// <summary>
        /// By default, when interceptors are enabled for a project, any
        /// interceptable usages of the enum will be replaced by usages of
        /// the extension method in this project. To disable interception of
        /// the enum in this project, set <see cref="IsInterceptable"/> to <c>false</c>.
        /// </summary>
        public bool IsInterceptable { get; set; } = true;
    }

    
    /// <summary>
    /// Add to enums to indicate that extension methods should be generated for the type
    /// </summary>
    [System.AttributeUsage(System.AttributeTargets.Assembly, AllowMultiple = true)]
    [System.Diagnostics.Conditional("NETESCAPADES_ENUMGENERATORS_USAGES")]
#if NET5_0_OR_GREATER
    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage(Justification = "Generated by the NetEscapades.EnumGenerators source generator.")]
#else
    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
#endif
    public class EnumExtensionsAttribute<T> : System.Attribute
        where T: System.Enum
    {
        /// <summary>
        /// The namespace to generate the extension class.
        /// If not provided, the namespace of the enum will be used
        /// </summary>
        public string? ExtensionClassNamespace { get; set; }

        /// <summary>
        /// The name to use for the extension class.
        /// If not provided, the enum name with ""Extensions"" will be used.
        /// For example for an Enum called StatusCodes, the default name
        /// will be StatusCodesExtensions
        /// </summary>
        public string? ExtensionClassName { get; set; }

        /// <summary>
        /// By default, when interceptors are enabled for a project, any
        /// interceptable usages of the enum will be replaced by usages of
        /// the extension method in this project. To disable interception of
        /// the enum in this project, set <see cref="IsInterceptable"/> to <c>false</c>.
        /// </summary>
        public bool IsInterceptable { get; set; } = true;
    }
}
#endif

  
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by the NetEscapades.EnumGenerators source generator
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

#nullable enable

namespace System
{
#pragma warning disable CS0612 // Ignore usages of obsolete members or enums
#pragma warning disable CS0618 // Ignore usages of obsolete members or enums
    /// <summary>
    /// Extension methods for <see cref="global::System.StringComparison" />
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("NetEscapades.EnumGenerators", "FIXED_VERSION")]
    public static partial class StringComparisonExtensions
    {
        /// <summary>
        /// The number of members in the enum.
        /// This is a non-distinct count of defined names.
        /// </summary>
        public const int Length = 6;

        /// <summary>
        /// Returns the string representation of the <see cref="global::System.StringComparison"/> value.
        /// If the attribute is decorated with a <c>[Display]</c> or <c>[Description]</c>attribute, then
        /// uses the provided value. Otherwise uses the name of the member, equivalent to
        /// calling <c>ToString()</c> on <paramref name="value"/>.
        /// </summary>
        /// <param name="value">The value to retrieve the string value for</param>
        /// <param name="useMetadataAttributes">If <c>true</c> uses the value provided in the
        /// <c>[Display]</c> or <c>[Description]</c>attribute as the string representation of the member.
        /// If <c>false</c>, always uses the name of the member, the same as if <c>ToString()</c> was called.</param>
        /// <returns>The string representation of the value</returns>
        public static string ToStringFast(this global::System.StringComparison value, bool useMetadataAttributes)
            => useMetadataAttributes ? value.ToStringFastWithMetadata() : value.ToStringFast();

        /// <summary>
        /// Returns the string representation of the <see cref="global::System.StringComparison"/> value.
        /// Directly equivalent to calling <c>ToString()</c> on <paramref name="value"/>.
        /// </summary>
        /// <param name="value">The value to retrieve the string value for</param>
        /// <returns>The string representation of the value, the same as that returned by <c>ToString()</c></returns>
        public static string ToStringFast(this global::System.StringComparison value)
            => value switch
            {
                global::System.StringComparison.CurrentCulture => nameof(global::System.StringComparison.CurrentCulture),
                global::System.StringComparison.CurrentCultureIgnoreCase => nameof(global::System.StringComparison.CurrentCultureIgnoreCase),
                global::System.StringComparison.InvariantCulture => nameof(global::System.StringComparison.InvariantCulture),
                global::System.StringComparison.InvariantCultureIgnoreCase => nameof(global::System.StringComparison.InvariantCultureIgnoreCase),
                global::System.StringComparison.Ordinal => nameof(global::System.StringComparison.Ordinal),
                global::System.StringComparison.OrdinalIgnoreCase => nameof(global::System.StringComparison.OrdinalIgnoreCase),
                _ => value.ToString(),
            };

        private static string ToStringFastWithMetadata(this global::System.StringComparison value)
            => value.ToStringFast();

        /// <summary>
        /// Returns a boolean telling whether the given enum value exists in the enumeration.
        /// </summary>
        /// <param name="value">The value to check if it's defined</param>
        /// <returns><c>true</c> if the value exists in the enumeration, <c>false</c> otherwise</returns>
        public static bool IsDefined(global::System.StringComparison value)
            => value switch
            {
                global::System.StringComparison.CurrentCulture => true,
                global::System.StringComparison.CurrentCultureIgnoreCase => true,
                global::System.StringComparison.InvariantCulture => true,
                global::System.StringComparison.InvariantCultureIgnoreCase => true,
                global::System.StringComparison.Ordinal => true,
                global::System.StringComparison.OrdinalIgnoreCase => true,
                _ => false,
            };

        /// <summary>
        /// Returns a boolean telling whether an enum with the given name exists in the enumeration.
        /// </summary>
        /// <param name="name">The name to check if it's defined</param>
        /// <returns><c>true</c> if a member with the name exists in the enumeration, <c>false</c> otherwise</returns>
        public static bool IsDefined(string name) => IsDefined(name, allowMatchingMetadataAttribute: false);

        /// <summary>
        /// Returns a boolean telling whether an enum with the given name exists in the enumeration,
        /// or if a member decorated with a <c>[Display]</c> attribute
        /// with the required name exists.
        /// </summary>
        /// <param name="name">The name to check if it's defined</param>
        /// <param name="allowMatchingMetadataAttribute">If <c>true</c>, considers the value of metadata attributes,otherwise ignores them</param>
        /// <returns><c>true</c> if a member with the name exists in the enumeration, or a member is decorated
        /// with a <c>[Display]</c> attribute with the name, <c>false</c> otherwise</returns>
        public static bool IsDefined(string name, bool allowMatchingMetadataAttribute)
        {
            return name switch
            {
                nameof(global::System.StringComparison.CurrentCulture) => true,
                nameof(global::System.StringComparison.CurrentCultureIgnoreCase) => true,
                nameof(global::System.StringComparison.InvariantCulture) => true,
                nameof(global::System.StringComparison.InvariantCultureIgnoreCase) => true,
                nameof(global::System.StringComparison.Ordinal) => true,
                nameof(global::System.StringComparison.OrdinalIgnoreCase) => true,
                _ => false,
            };
        }

#if NETCOREAPP && !NETCOREAPP2_0 && !NETCOREAPP1_1 && !NETCOREAPP1_0
        /// <summary>
        /// Returns a boolean telling whether an enum with the given name exists in the enumeration
        /// </summary>
        /// <param name="name">The name to check if it's defined</param>
        /// <returns><c>true</c> if a member with the name exists in the enumeration, <c>false</c> otherwise</returns>
        public static bool IsDefined(in global::System.ReadOnlySpan<char> name) => IsDefined(name, allowMatchingMetadataAttribute: false);

        /// <summary>
        /// Returns a boolean telling whether an enum with the given name exists in the enumeration,
        /// or optionally if a member decorated with a <c>[Display]</c> attribute
        /// with the required name exists.
        /// Slower then the <see cref="IsDefined(string, bool)" /> overload, but doesn't allocate memory./>
        /// </summary>
        /// <param name="name">The name to check if it's defined</param>
        /// <param name="allowMatchingMetadataAttribute">If <c>true</c>, considers the value of metadata attributes,otherwise ignores them</param>
        /// <returns><c>true</c> if a member with the name exists in the enumeration, or a member is decorated
        /// with a <c>[Display]</c> attribute with the name, <c>false</c> otherwise</returns>
        public static bool IsDefined(in global::System.ReadOnlySpan<char> name, bool allowMatchingMetadataAttribute)
        {
            return name switch
            {
                global::System.ReadOnlySpan<char> current when global::System.MemoryExtensions.Equals(current, nameof(global::System.StringComparison.CurrentCulture), global::System.StringComparison.Ordinal) => true,
                global::System.ReadOnlySpan<char> current when global::System.MemoryExtensions.Equals(current, nameof(global::System.StringComparison.CurrentCultureIgnoreCase), global::System.StringComparison.Ordinal) => true,
                global::System.ReadOnlySpan<char> current when global::System.MemoryExtensions.Equals(current, nameof(global::System.StringComparison.InvariantCulture), global::System.StringComparison.Ordinal) => true,
                global::System.ReadOnlySpan<char> current when global::System.MemoryExtensions.Equals(current, nameof(global::System.StringComparison.InvariantCultureIgnoreCase), global::System.StringComparison.Ordinal) => true,
                global::System.ReadOnlySpan<char> current when global::System.MemoryExtensions.Equals(current, nameof(global::System.StringComparison.Ordinal), global::System.StringComparison.Ordinal) => true,
                global::System.ReadOnlySpan<char> current when global::System.MemoryExtensions.Equals(current, nameof(global::System.StringComparison.OrdinalIgnoreCase), global::System.StringComparison.Ordinal) => true,
                _ => false,
            };
        }
#endif

        /// <summary>
        /// Converts the string representation of the name or numeric value of
        /// an <see cref="global::System.StringComparison" /> to the equivalent instance.
        /// </summary>
        /// <param name="name">The case-sensitive string representation of the enumeration name or underlying value to convert</param>
        /// <returns>An object of type <see cref="global::System.StringComparison" /> whose
        /// value is represented by <paramref name="name"/></returns>
        public static global::System.StringComparison Parse(
#if NETCOREAPP3_0_OR_GREATER
            [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)]
#endif
            string? name)
                => TryParse(name, out var value, false, false) ? value : ThrowValueNotFound(name);

        /// <summary>
        /// Converts the string representation of the name or numeric value of
        /// an <see cref="global::System.StringComparison" /> to the equivalent instance.
        /// </summary>
        /// <param name="name">The case-sensitive string representation of the enumeration name or underlying value to convert</param>
        /// <param name="ignoreCase"><c>true</c> to read value in case insensitive mode; <c>false</c> to read value in case sensitive mode.</param>
        /// <returns>An object of type <see cref="global::System.StringComparison" /> whose
        /// value is represented by <paramref name="name"/></returns>
        public static global::System.StringComparison Parse(
#if NETCOREAPP3_0_OR_GREATER
            [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)]
#endif
            string? name,
            bool ignoreCase)
                => TryParse(name, out var value, ignoreCase, false) ? value : ThrowValueNotFound(name);

        /// <summary>
        /// Converts the string representation of the name or numeric value of
        /// an <see cref="global::System.StringComparison" /> to the equivalent instance.
        /// </summary>
        /// <param name="name">The case-sensitive string representation of the enumeration name or underlying value to convert</param>
        /// <param name="ignoreCase"><c>true</c> to read value in case insensitive mode; <c>false</c> to read value in case sensitive mode.</param>
        /// <param name="allowMatchingMetadataAttribute">If <c>true</c>, considers the value included in metadata attributes such as
        /// <c>[Display]</c> attribute when parsing, otherwise only considers the member names.</param>
        /// <returns>An object of type <see cref="global::System.StringComparison" /> whose
        /// value is represented by <paramref name="name"/></returns>
        public static global::System.StringComparison Parse(
#if NETCOREAPP3_0_OR_GREATER
            [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)]
#endif
            string? name,
            bool ignoreCase,
            bool allowMatchingMetadataAttribute)
                => TryParse(name, out var value, ignoreCase, allowMatchingMetadataAttribute) ? value : ThrowValueNotFound(name);
    
#if NETCOREAPP3_0_OR_GREATER
        [global::System.Diagnostics.CodeAnalysis.DoesNotReturn]
#endif
        private static global::System.StringComparison ThrowValueNotFound(string? name)
            => throw new global::System.ArgumentException($"Requested value '{name}' was not found.");

        /// <summary>
        /// Converts the string representation of the name or numeric value of
        /// an <see cref="global::System.StringComparison" /> to the equivalent instance.
        /// The return value indicates whether the conversion succeeded.
        /// </summary>
        /// <param name="name">The case-sensitive string representation of the enumeration name or underlying value to convert</param>
        /// <param name="value">When this method returns, contains an object of type 
        /// <see cref="global::System.StringComparison" /> whose
        /// value is represented by <paramref name="value"/> if the parse operation succeeds.
        /// If the parse operation fails, contains the default value of the underlying type
        /// of <see cref="global::System.StringComparison" />. This parameter is passed uninitialized.</param>
        /// <returns><c>true</c> if the value parameter was converted successfully; otherwise, <c>false</c>.</returns>
        public static bool TryParse(
#if NETCOREAPP3_0_OR_GREATER
            [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)]
#endif
            string? name, 
            out global::System.StringComparison value)
            => TryParse(name, out value, false, false);

        /// <summary>
        /// Converts the string representation of the name or numeric value of
        /// an <see cref="global::System.StringComparison" /> to the equivalent instance.
        /// The return value indicates whether the conversion succeeded.
        /// </summary>
        /// <param name="name">The string representation of the enumeration name or underlying value to convert</param>
        /// <param name="value">When this method returns, contains an object of type 
        /// <see cref="global::System.StringComparison" /> whose
        /// value is represented by <paramref name="value"/> if the parse operation succeeds.
        /// If the parse operation fails, contains the default value of the underlying type
        /// of <see cref="global::System.StringComparison" />. This parameter is passed uninitialized.</param>
        /// <param name="ignoreCase"><c>true</c> to read value in case insensitive mode; <c>false</c> to read value in case sensitive mode.</param>
        /// <returns><c>true</c> if the value parameter was converted successfully; otherwise, <c>false</c>.</returns>
        public static bool TryParse(
#if NETCOREAPP3_0_OR_GREATER
            [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)]
#endif
            string? name, 
            out global::System.StringComparison value,
            bool ignoreCase) 
            => TryParse(name, out value, ignoreCase, false);

        /// <summary>
        /// Converts the string representation of the name or numeric value of
        /// an <see cref="global::System.StringComparison" /> to the equivalent instance.
        /// The return value indicates whether the conversion succeeded.
        /// </summary>
        /// <param name="name">The string representation of the enumeration name or underlying value to convert</param>
        /// <param name="value">When this method returns, contains an object of type 
        /// <see cref="global::System.StringComparison" /> whose
        /// value is represented by <paramref name="value"/> if the parse operation succeeds.
        /// If the parse operation fails, contains the default value of the underlying type
        /// of <see cref="global::System.StringComparison" />. This parameter is passed uninitialized.</param>
        /// <param name="ignoreCase"><c>true</c> to read value in case insensitive mode; <c>false</c> to read value in case sensitive mode.</param>
        /// <param name="allowMatchingMetadataAttribute">If <c>true</c>, considers the value included in metadata attributes such as
        /// <c>[Display]</c> attribute when parsing, otherwise only considers the member names.</param>
        /// <returns><c>true</c> if the value parameter was converted successfully; otherwise, <c>false</c>.</returns>
        public static bool TryParse(
#if NETCOREAPP3_0_OR_GREATER
            [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)]
#endif
            string? name, 
            out global::System.StringComparison value, 
            bool ignoreCase,
            bool allowMatchingMetadataAttribute)
                => ignoreCase
                    ? TryParseIgnoreCase(name, out value, allowMatchingMetadataAttribute)
                    : TryParseWithCase(name, out value, allowMatchingMetadataAttribute);

        private static bool TryParseIgnoreCase(
#if NETCOREAPP3_0_OR_GREATER
            [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)]
#endif
            string? name,
            out global::System.StringComparison value,
            bool allowMatchingMetadataAttribute)
        {

            switch (name)
            {
                case string s when s.Equals(nameof(global::System.StringComparison.CurrentCulture), global::System.StringComparison.OrdinalIgnoreCase):
                    value = global::System.StringComparison.CurrentCulture;
                    return true;
                case string s when s.Equals(nameof(global::System.StringComparison.CurrentCultureIgnoreCase), global::System.StringComparison.OrdinalIgnoreCase):
                    value = global::System.StringComparison.CurrentCultureIgnoreCase;
                    return true;
                case string s when s.Equals(nameof(global::System.StringComparison.InvariantCulture), global::System.StringComparison.OrdinalIgnoreCase):
                    value = global::System.StringComparison.InvariantCulture;
                    return true;
                case string s when s.Equals(nameof(global::System.StringComparison.InvariantCultureIgnoreCase), global::System.StringComparison.OrdinalIgnoreCase):
                    value = global::System.StringComparison.InvariantCultureIgnoreCase;
                    return true;
                case string s when s.Equals(nameof(global::System.StringComparison.Ordinal), global::System.StringComparison.OrdinalIgnoreCase):
                    value = global::System.StringComparison.Ordinal;
                    return true;
                case string s when s.Equals(nameof(global::System.StringComparison.OrdinalIgnoreCase), global::System.StringComparison.OrdinalIgnoreCase):
                    value = global::System.StringComparison.OrdinalIgnoreCase;
                    return true;
                case string s when int.TryParse(name, out var val):
                    value = (global::System.StringComparison)val;
                    return true;
                default:
                    value = default;
                    return false;
            }
        }

        private static bool TryParseWithCase(
#if NETCOREAPP3_0_OR_GREATER
            [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)]
#endif
            string? name,
            out global::System.StringComparison value,
            bool allowMatchingMetadataAttribute)
        {

            switch (name)
            {
                case nameof(global::System.StringComparison.CurrentCulture):
                    value = global::System.StringComparison.CurrentCulture;
                    return true;
                case nameof(global::System.StringComparison.CurrentCultureIgnoreCase):
                    value = global::System.StringComparison.CurrentCultureIgnoreCase;
                    return true;
                case nameof(global::System.StringComparison.InvariantCulture):
                    value = global::System.StringComparison.InvariantCulture;
                    return true;
                case nameof(global::System.StringComparison.InvariantCultureIgnoreCase):
                    value = global::System.StringComparison.InvariantCultureIgnoreCase;
                    return true;
                case nameof(global::System.StringComparison.Ordinal):
                    value = global::System.StringComparison.Ordinal;
                    return true;
                case nameof(global::System.StringComparison.OrdinalIgnoreCase):
                    value = global::System.StringComparison.OrdinalIgnoreCase;
                    return true;
                case string s when int.TryParse(name, out var val):
                    value = (global::System.StringComparison)val;
                    return true;
                default:
                    value = default;
                    return false;
            }
        }

#if NETCOREAPP && !NETCOREAPP2_0 && !NETCOREAPP1_1 && !NETCOREAPP1_0
        /// <summary>
        /// Converts the string representation of the name or numeric value of
        /// an <see cref="global::System.StringComparison" /> to the equivalent instance.
        /// </summary>
        /// <param name="name">The case-sensitive string representation of the enumeration name or underlying value to convert</param>
        /// <returns>An object of type <see cref="global::System.StringComparison" /> whose
        /// value is represented by <paramref name="name"/></returns>
        public static global::System.StringComparison Parse(
#if NETCOREAPP3_0_OR_GREATER
            [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)]
#endif
            in global::System.ReadOnlySpan<char> name)
                => TryParse(name, out var value, false, false) ? value : ThrowValueNotFound(name.ToString());

        /// <summary>
        /// Converts the string representation of the name or numeric value of
        /// an <see cref="global::System.StringComparison" /> to the equivalent instance.
        /// </summary>
        /// <param name="name">The case-sensitive string representation of the enumeration name or underlying value to convert</param>
        /// <param name="ignoreCase"><c>true</c> to read value in case insensitive mode; <c>false</c> to read value in case sensitive mode.</param>
        /// <returns>An object of type <see cref="global::System.StringComparison" /> whose
        /// value is represented by <paramref name="name"/></returns>
        public static global::System.StringComparison Parse(
#if NETCOREAPP3_0_OR_GREATER
            [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)]
#endif
            in global::System.ReadOnlySpan<char> name,
            bool ignoreCase)
                => TryParse(name, out var value, ignoreCase, false) ? value : ThrowValueNotFound(name.ToString());

        /// <summary>
        /// Converts the string representation of the name or numeric value of
        /// an <see cref="global::System.StringComparison" /> to the equivalent instance.
        /// </summary>
        /// <param name="name">The case-sensitive string representation of the enumeration name or underlying value to convert</param>
        /// <param name="ignoreCase"><c>true</c> to read value in case insensitive mode; <c>false</c> to read value in case sensitive mode.</param>
        /// <param name="allowMatchingMetadataAttribute">If <c>true</c>, considers the value included in metadata attributes such as
        /// <c>[Display]</c> attribute when parsing, otherwise only considers the member names.</param>
        /// <returns>An object of type <see cref="global::System.StringComparison" /> whose
        /// value is represented by <paramref name="name"/></returns>
        public static global::System.StringComparison Parse(
#if NETCOREAPP3_0_OR_GREATER
            [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)]
#endif
            in global::System.ReadOnlySpan<char> name,
            bool ignoreCase,
            bool allowMatchingMetadataAttribute)
                => TryParse(name, out var value, ignoreCase, allowMatchingMetadataAttribute) ? value : ThrowValueNotFound(name.ToString());

        /// <summary>
        /// Converts the span representation of the name or numeric value of
        /// an <see cref="global::System.StringComparison" /> to the equivalent instance.
        /// The return value indicates whether the conversion succeeded.
        /// </summary>
        /// <param name="name">The span representation of the enumeration name or underlying value to convert</param>
        /// <param name="value">When this method returns, contains an object of type 
        /// <see cref="global::System.StringComparison" /> whose
        /// value is represented by <paramref name="value"/> if the parse operation succeeds.
        /// If the parse operation fails, contains the default value of the underlying type
        /// of <see cref="global::System.StringComparison" />. This parameter is passed uninitialized.</param>
        /// <returns><c>true</c> if the value parameter was converted successfully; otherwise, <c>false</c>.</returns>
        public static bool TryParse(
#if NETCOREAPP3_0_OR_GREATER
            [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)]
#endif
            in global::System.ReadOnlySpan<char> name, 
            out global::System.StringComparison value)
            => TryParse(name, out value, false, false);

        /// <summary>
        /// Converts the span representation of the name or numeric value of
        /// an <see cref="global::System.StringComparison" /> to the equivalent instance.
        /// The return value indicates whether the conversion succeeded.
        /// </summary>
        /// <param name="name">The span representation of the enumeration name or underlying value to convert</param>
        /// <param name="value">When this method returns, contains an object of type 
        /// <see cref="global::System.StringComparison" /> whose
        /// value is represented by <paramref name="value"/> if the parse operation succeeds.
        /// If the parse operation fails, contains the default value of the underlying type
        /// of <see cref="global::System.StringComparison" />. This parameter is passed uninitialized.</param>
        /// <param name="ignoreCase"><c>true</c> to read value in case insensitive mode; <c>false</c> to read value in case sensitive mode.</param>
        /// <returns><c>true</c> if the value parameter was converted successfully; otherwise, <c>false</c>.</returns>
        public static bool TryParse(
#if NETCOREAPP3_0_OR_GREATER
            [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)]
#endif
            in global::System.ReadOnlySpan<char> name,
            out global::System.StringComparison value,
            bool ignoreCase)
            => TryParse(name, out value, ignoreCase, false);

        /// <summary>
        /// Converts the span representation of the name or numeric value of
        /// an <see cref="global::System.StringComparison" /> to the equivalent instance.
        /// The return value indicates whether the conversion succeeded.
        /// </summary>
        /// <param name="name">The span representation of the enumeration name or underlying value to convert</param>
        /// <param name="result">When this method returns, contains an object of type 
        /// <see cref="global::System.StringComparison" /> whose
        /// value is represented by <paramref name="result"/> if the parse operation succeeds.
        /// If the parse operation fails, contains the default value of the underlying type
        /// of <see cref="global::System.StringComparison" />. This parameter is passed uninitialized.</param>
        /// <param name="ignoreCase"><c>true</c> to read value in case insensitive mode; <c>false</c> to read value in case sensitive mode.</param>
        /// <param name="allowMatchingMetadataAttribute">If <c>true</c>, considers the value included in metadata attributes such as
        /// <c>[Display]</c> attribute when parsing, otherwise only considers the member names.</param>
        /// <returns><c>true</c> if the value parameter was converted successfully; otherwise, <c>false</c>.</returns>
        public static bool TryParse(
#if NETCOREAPP3_0_OR_GREATER
            [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)]
#endif
            in global::System.ReadOnlySpan<char> name,
            out global::System.StringComparison result,
            bool ignoreCase,
            bool allowMatchingMetadataAttribute)
                => ignoreCase
                    ? TryParseIgnoreCase(in name, out result, allowMatchingMetadataAttribute)
                    : TryParseWithCase(in name, out result, allowMatchingMetadataAttribute);

        private static bool TryParseIgnoreCase(
#if NETCOREAPP3_0_OR_GREATER
            [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)]
#endif
            in global::System.ReadOnlySpan<char> name,
            out global::System.StringComparison result,
            bool allowMatchingMetadataAttribute)
        {
            switch (name)
            {
                case global::System.ReadOnlySpan<char> current when global::System.MemoryExtensions.Equals(current, nameof(global::System.StringComparison.CurrentCulture), global::System.StringComparison.OrdinalIgnoreCase):
                    result = global::System.StringComparison.CurrentCulture;
                    return true;
                case global::System.ReadOnlySpan<char> current when global::System.MemoryExtensions.Equals(current, nameof(global::System.StringComparison.CurrentCultureIgnoreCase), global::System.StringComparison.OrdinalIgnoreCase):
                    result = global::System.StringComparison.CurrentCultureIgnoreCase;
                    return true;
                case global::System.ReadOnlySpan<char> current when global::System.MemoryExtensions.Equals(current, nameof(global::System.StringComparison.InvariantCulture), global::System.StringComparison.OrdinalIgnoreCase):
                    result = global::System.StringComparison.InvariantCulture;
                    return true;
                case global::System.ReadOnlySpan<char> current when global::System.MemoryExtensions.Equals(current, nameof(global::System.StringComparison.InvariantCultureIgnoreCase), global::System.StringComparison.OrdinalIgnoreCase):
                    result = global::System.StringComparison.InvariantCultureIgnoreCase;
                    return true;
                case global::System.ReadOnlySpan<char> current when global::System.MemoryExtensions.Equals(current, nameof(global::System.StringComparison.Ordinal), global::System.StringComparison.OrdinalIgnoreCase):
                    result = global::System.StringComparison.Ordinal;
                    return true;
                case global::System.ReadOnlySpan<char> current when global::System.MemoryExtensions.Equals(current, nameof(global::System.StringComparison.OrdinalIgnoreCase), global::System.StringComparison.OrdinalIgnoreCase):
                    result = global::System.StringComparison.OrdinalIgnoreCase;
                    return true;
                case global::System.ReadOnlySpan<char> current when int.TryParse(name, out var numericResult):
                    result = (global::System.StringComparison)numericResult;
                    return true;
                default:
                    result = default;
                    return false;
            }
        }

        private static bool TryParseWithCase(
#if NETCOREAPP3_0_OR_GREATER
            [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)]
#endif
            in global::System.ReadOnlySpan<char> name,
            out global::System.StringComparison result,
            bool allowMatchingMetadataAttribute)
        {
            switch (name)
            {
                case global::System.ReadOnlySpan<char> current when global::System.MemoryExtensions.Equals(current, nameof(global::System.StringComparison.CurrentCulture), global::System.StringComparison.Ordinal):
                    result = global::System.StringComparison.CurrentCulture;
                    return true;
                case global::System.ReadOnlySpan<char> current when global::System.MemoryExtensions.Equals(current, nameof(global::System.StringComparison.CurrentCultureIgnoreCase), global::System.StringComparison.Ordinal):
                    result = global::System.StringComparison.CurrentCultureIgnoreCase;
                    return true;
                case global::System.ReadOnlySpan<char> current when global::System.MemoryExtensions.Equals(current, nameof(global::System.StringComparison.InvariantCulture), global::System.StringComparison.Ordinal):
                    result = global::System.StringComparison.InvariantCulture;
                    return true;
                case global::System.ReadOnlySpan<char> current when global::System.MemoryExtensions.Equals(current, nameof(global::System.StringComparison.InvariantCultureIgnoreCase), global::System.StringComparison.Ordinal):
                    result = global::System.StringComparison.InvariantCultureIgnoreCase;
                    return true;
                case global::System.ReadOnlySpan<char> current when global::System.MemoryExtensions.Equals(current, nameof(global::System.StringComparison.Ordinal), global::System.StringComparison.Ordinal):
                    result = global::System.StringComparison.Ordinal;
                    return true;
                case global::System.ReadOnlySpan<char> current when global::System.MemoryExtensions.Equals(current, nameof(global::System.StringComparison.OrdinalIgnoreCase), global::System.StringComparison.Ordinal):
                    result = global::System.StringComparison.OrdinalIgnoreCase;
                    return true;
                case global::System.ReadOnlySpan<char> current when int.TryParse(name, out var numericResult):
                    result = (global::System.StringComparison)numericResult;
                    return true;
                default:
                    result = default;
                    return false;
            }
        }
#endif

        /// <summary>
        /// Cast a value of <see cref="global::System.StringComparison" /> to the underlying type (<c>int</c>).
        /// This is mainly a convenience method.
        /// </summary>
        /// <returns>The value of <see cref="global::System.StringComparison" /> cast to the underlying type.</returns>
        public static int AsUnderlyingType(this global::System.StringComparison value)
        {
            return (int) value;
        }

        /// <summary>
        /// Retrieves an array of the values of the members defined in
        /// <see cref="global::System.StringComparison" />.
        /// Note that this returns a new array with every invocation, so
        /// should be cached if appropriate.
        /// </summary>
        /// <returns>An array of the values defined in <see cref="global::System.StringComparison" /></returns>
        public static global::System.StringComparison[] GetValues()
        {
            return new[]
            {
                global::System.StringComparison.CurrentCulture,
                global::System.StringComparison.CurrentCultureIgnoreCase,
                global::System.StringComparison.InvariantCulture,
                global::System.StringComparison.InvariantCultureIgnoreCase,
                global::System.StringComparison.Ordinal,
                global::System.StringComparison.OrdinalIgnoreCase,
            };
        }

        /// <summary>
        /// Retrieves an array of the underlying-values of the members defined in
        /// <see cref="global::System.StringComparison" />.
        /// Note that this returns a new array with every invocation, so
        /// should be cached if appropriate.
        /// </summary>
        /// <returns>An array of the underlying-values defined in <see cref="global::System.StringComparison" /></returns>
        public static int[] GetValuesAsUnderlyingType()
        {
            return new[]
            {
                (int) global::System.StringComparison.CurrentCulture,
                (int) global::System.StringComparison.CurrentCultureIgnoreCase,
                (int) global::System.StringComparison.InvariantCulture,
                (int) global::System.StringComparison.InvariantCultureIgnoreCase,
                (int) global::System.StringComparison.Ordinal,
                (int) global::System.StringComparison.OrdinalIgnoreCase,
            };
        }

        /// <summary>
        /// Retrieves an array of the names of the members defined in
        /// <see cref="global::System.StringComparison" />.
        /// Note that this returns a new array with every invocation, so
        /// should be cached if appropriate.
        /// </summary>
        /// <returns>An array of the names of the members defined in <see cref="global::System.StringComparison" /></returns>
        public static string[] GetNames()
        {
            return new[]
            {
                nameof(global::System.StringComparison.CurrentCulture),
                nameof(global::System.StringComparison.CurrentCultureIgnoreCase),
                nameof(global::System.StringComparison.InvariantCulture),
                nameof(global::System.StringComparison.InvariantCultureIgnoreCase),
                nameof(global::System.StringComparison.Ordinal),
                nameof(global::System.StringComparison.OrdinalIgnoreCase),
            };
        }
    }
#pragma warning restore CS0612 // Ignore usages of obsolete members or enums
#pragma warning restore CS0618 // Ignore usages of obsolete members or enums
}
  
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by the NetEscapades.EnumGenerators source generator
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

#nullable enable

namespace System
{
#pragma warning disable CS0612 // Ignore usages of obsolete members or enums
#pragma warning disable CS0618 // Ignore usages of obsolete members or enums
    /// <summary>
    /// Extension methods for <see cref="global::System.DateTimeKind" />
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("NetEscapades.EnumGenerators", "FIXED_VERSION")]
    public static partial class DateTimeKindExtensions
    {
        /// <summary>
        /// The number of members in the enum.
        /// This is a non-distinct count of defined names.
        /// </summary>
        public const int Length = 3;

        /// <summary>
        /// Returns the string representation of the <see cref="global::System.DateTimeKind"/> value.
        /// If the attribute is decorated with a <c>[Display]</c> or <c>[Description]</c>attribute, then
        /// uses the provided value. Otherwise uses the name of the member, equivalent to
        /// calling <c>ToString()</c> on <paramref name="value"/>.
        /// </summary>
        /// <param name="value">The value to retrieve the string value for</param>
        /// <param name="useMetadataAttributes">If <c>true</c> uses the value provided in the
        /// <c>[Display]</c> or <c>[Description]</c>attribute as the string representation of the member.
        /// If <c>false</c>, always uses the name of the member, the same as if <c>ToString()</c> was called.</param>
        /// <returns>The string representation of the value</returns>
        public static string ToStringFast(this global::System.DateTimeKind value, bool useMetadataAttributes)
            => useMetadataAttributes ? value.ToStringFastWithMetadata() : value.ToStringFast();

        /// <summary>
        /// Returns the string representation of the <see cref="global::System.DateTimeKind"/> value.
        /// Directly equivalent to calling <c>ToString()</c> on <paramref name="value"/>.
        /// </summary>
        /// <param name="value">The value to retrieve the string value for</param>
        /// <returns>The string representation of the value, the same as that returned by <c>ToString()</c></returns>
        public static string ToStringFast(this global::System.DateTimeKind value)
            => value switch
            {
                global::System.DateTimeKind.Unspecified => nameof(global::System.DateTimeKind.Unspecified),
                global::System.DateTimeKind.Utc => nameof(global::System.DateTimeKind.Utc),
                global::System.DateTimeKind.Local => nameof(global::System.DateTimeKind.Local),
                _ => value.ToString(),
            };

        private static string ToStringFastWithMetadata(this global::System.DateTimeKind value)
            => value.ToStringFast();

        /// <summary>
        /// Returns a boolean telling whether the given enum value exists in the enumeration.
        /// </summary>
        /// <param name="value">The value to check if it's defined</param>
        /// <returns><c>true</c> if the value exists in the enumeration, <c>false</c> otherwise</returns>
        public static bool IsDefined(global::System.DateTimeKind value)
            => value switch
            {
                global::System.DateTimeKind.Unspecified => true,
                global::System.DateTimeKind.Utc => true,
                global::System.DateTimeKind.Local => true,
                _ => false,
            };

        /// <summary>
        /// Returns a boolean telling whether an enum with the given name exists in the enumeration.
        /// </summary>
        /// <param name="name">The name to check if it's defined</param>
        /// <returns><c>true</c> if a member with the name exists in the enumeration, <c>false</c> otherwise</returns>
        public static bool IsDefined(string name) => IsDefined(name, allowMatchingMetadataAttribute: false);

        /// <summary>
        /// Returns a boolean telling whether an enum with the given name exists in the enumeration,
        /// or if a member decorated with a <c>[Display]</c> attribute
        /// with the required name exists.
        /// </summary>
        /// <param name="name">The name to check if it's defined</param>
        /// <param name="allowMatchingMetadataAttribute">If <c>true</c>, considers the value of metadata attributes,otherwise ignores them</param>
        /// <returns><c>true</c> if a member with the name exists in the enumeration, or a member is decorated
        /// with a <c>[Display]</c> attribute with the name, <c>false</c> otherwise</returns>
        public static bool IsDefined(string name, bool allowMatchingMetadataAttribute)
        {
            return name switch
            {
                nameof(global::System.DateTimeKind.Unspecified) => true,
                nameof(global::System.DateTimeKind.Utc) => true,
                nameof(global::System.DateTimeKind.Local) => true,
                _ => false,
            };
        }

#if NETCOREAPP && !NETCOREAPP2_0 && !NETCOREAPP1_1 && !NETCOREAPP1_0
        /// <summary>
        /// Returns a boolean telling whether an enum with the given name exists in the enumeration
        /// </summary>
        /// <param name="name">The name to check if it's defined</param>
        /// <returns><c>true</c> if a member with the name exists in the enumeration, <c>false</c> otherwise</returns>
        public static bool IsDefined(in global::System.ReadOnlySpan<char> name) => IsDefined(name, allowMatchingMetadataAttribute: false);

        /// <summary>
        /// Returns a boolean telling whether an enum with the given name exists in the enumeration,
        /// or optionally if a member decorated with a <c>[Display]</c> attribute
        /// with the required name exists.
        /// Slower then the <see cref="IsDefined(string, bool)" /> overload, but doesn't allocate memory./>
        /// </summary>
        /// <param name="name">The name to check if it's defined</param>
        /// <param name="allowMatchingMetadataAttribute">If <c>true</c>, considers the value of metadata attributes,otherwise ignores them</param>
        /// <returns><c>true</c> if a member with the name exists in the enumeration, or a member is decorated
        /// with a <c>[Display]</c> attribute with the name, <c>false</c> otherwise</returns>
        public static bool IsDefined(in global::System.ReadOnlySpan<char> name, bool allowMatchingMetadataAttribute)
        {
            return name switch
            {
                global::System.ReadOnlySpan<char> current when global::System.MemoryExtensions.Equals(current, nameof(global::System.DateTimeKind.Unspecified), global::System.StringComparison.Ordinal) => true,
                global::System.ReadOnlySpan<char> current when global::System.MemoryExtensions.Equals(current, nameof(global::System.DateTimeKind.Utc), global::System.StringComparison.Ordinal) => true,
                global::System.ReadOnlySpan<char> current when global::System.MemoryExtensions.Equals(current, nameof(global::System.DateTimeKind.Local), global::System.StringComparison.Ordinal) => true,
                _ => false,
            };
        }
#endif

        /// <summary>
        /// Converts the string representation of the name or numeric value of
        /// an <see cref="global::System.DateTimeKind" /> to the equivalent instance.
        /// </summary>
        /// <param name="name">The case-sensitive string representation of the enumeration name or underlying value to convert</param>
        /// <returns>An object of type <see cref="global::System.DateTimeKind" /> whose
        /// value is represented by <paramref name="name"/></returns>
        public static global::System.DateTimeKind Parse(
#if NETCOREAPP3_0_OR_GREATER
            [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)]
#endif
            string? name)
                => TryParse(name, out var value, false, false) ? value : ThrowValueNotFound(name);

        /// <summary>
        /// Converts the string representation of the name or numeric value of
        /// an <see cref="global::System.DateTimeKind" /> to the equivalent instance.
        /// </summary>
        /// <param name="name">The case-sensitive string representation of the enumeration name or underlying value to convert</param>
        /// <param name="ignoreCase"><c>true</c> to read value in case insensitive mode; <c>false</c> to read value in case sensitive mode.</param>
        /// <returns>An object of type <see cref="global::System.DateTimeKind" /> whose
        /// value is represented by <paramref name="name"/></returns>
        public static global::System.DateTimeKind Parse(
#if NETCOREAPP3_0_OR_GREATER
            [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)]
#endif
            string? name,
            bool ignoreCase)
                => TryParse(name, out var value, ignoreCase, false) ? value : ThrowValueNotFound(name);

        /// <summary>
        /// Converts the string representation of the name or numeric value of
        /// an <see cref="global::System.DateTimeKind" /> to the equivalent instance.
        /// </summary>
        /// <param name="name">The case-sensitive string representation of the enumeration name or underlying value to convert</param>
        /// <param name="ignoreCase"><c>true</c> to read value in case insensitive mode; <c>false</c> to read value in case sensitive mode.</param>
        /// <param name="allowMatchingMetadataAttribute">If <c>true</c>, considers the value included in metadata attributes such as
        /// <c>[Display]</c> attribute when parsing, otherwise only considers the member names.</param>
        /// <returns>An object of type <see cref="global::System.DateTimeKind" /> whose
        /// value is represented by <paramref name="name"/></returns>
        public static global::System.DateTimeKind Parse(
#if NETCOREAPP3_0_OR_GREATER
            [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)]
#endif
            string? name,
            bool ignoreCase,
            bool allowMatchingMetadataAttribute)
                => TryParse(name, out var value, ignoreCase, allowMatchingMetadataAttribute) ? value : ThrowValueNotFound(name);
    
#if NETCOREAPP3_0_OR_GREATER
        [global::System.Diagnostics.CodeAnalysis.DoesNotReturn]
#endif
        private static global::System.DateTimeKind ThrowValueNotFound(string? name)
            => throw new global::System.ArgumentException($"Requested value '{name}' was not found.");

        /// <summary>
        /// Converts the string representation of the name or numeric value of
        /// an <see cref="global::System.DateTimeKind" /> to the equivalent instance.
        /// The return value indicates whether the conversion succeeded.
        /// </summary>
        /// <param name="name">The case-sensitive string representation of the enumeration name or underlying value to convert</param>
        /// <param name="value">When this method returns, contains an object of type 
        /// <see cref="global::System.DateTimeKind" /> whose
        /// value is represented by <paramref name="value"/> if the parse operation succeeds.
        /// If the parse operation fails, contains the default value of the underlying type
        /// of <see cref="global::System.DateTimeKind" />. This parameter is passed uninitialized.</param>
        /// <returns><c>true</c> if the value parameter was converted successfully; otherwise, <c>false</c>.</returns>
        public static bool TryParse(
#if NETCOREAPP3_0_OR_GREATER
            [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)]
#endif
            string? name, 
            out global::System.DateTimeKind value)
            => TryParse(name, out value, false, false);

        /// <summary>
        /// Converts the string representation of the name or numeric value of
        /// an <see cref="global::System.DateTimeKind" /> to the equivalent instance.
        /// The return value indicates whether the conversion succeeded.
        /// </summary>
        /// <param name="name">The string representation of the enumeration name or underlying value to convert</param>
        /// <param name="value">When this method returns, contains an object of type 
        /// <see cref="global::System.DateTimeKind" /> whose
        /// value is represented by <paramref name="value"/> if the parse operation succeeds.
        /// If the parse operation fails, contains the default value of the underlying type
        /// of <see cref="global::System.DateTimeKind" />. This parameter is passed uninitialized.</param>
        /// <param name="ignoreCase"><c>true</c> to read value in case insensitive mode; <c>false</c> to read value in case sensitive mode.</param>
        /// <returns><c>true</c> if the value parameter was converted successfully; otherwise, <c>false</c>.</returns>
        public static bool TryParse(
#if NETCOREAPP3_0_OR_GREATER
            [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)]
#endif
            string? name, 
            out global::System.DateTimeKind value,
            bool ignoreCase) 
            => TryParse(name, out value, ignoreCase, false);

        /// <summary>
        /// Converts the string representation of the name or numeric value of
        /// an <see cref="global::System.DateTimeKind" /> to the equivalent instance.
        /// The return value indicates whether the conversion succeeded.
        /// </summary>
        /// <param name="name">The string representation of the enumeration name or underlying value to convert</param>
        /// <param name="value">When this method returns, contains an object of type 
        /// <see cref="global::System.DateTimeKind" /> whose
        /// value is represented by <paramref name="value"/> if the parse operation succeeds.
        /// If the parse operation fails, contains the default value of the underlying type
        /// of <see cref="global::System.DateTimeKind" />. This parameter is passed uninitialized.</param>
        /// <param name="ignoreCase"><c>true</c> to read value in case insensitive mode; <c>false</c> to read value in case sensitive mode.</param>
        /// <param name="allowMatchingMetadataAttribute">If <c>true</c>, considers the value included in metadata attributes such as
        /// <c>[Display]</c> attribute when parsing, otherwise only considers the member names.</param>
        /// <returns><c>true</c> if the value parameter was converted successfully; otherwise, <c>false</c>.</returns>
        public static bool TryParse(
#if NETCOREAPP3_0_OR_GREATER
            [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)]
#endif
            string? name, 
            out global::System.DateTimeKind value, 
            bool ignoreCase,
            bool allowMatchingMetadataAttribute)
                => ignoreCase
                    ? TryParseIgnoreCase(name, out value, allowMatchingMetadataAttribute)
                    : TryParseWithCase(name, out value, allowMatchingMetadataAttribute);

        private static bool TryParseIgnoreCase(
#if NETCOREAPP3_0_OR_GREATER
            [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)]
#endif
            string? name,
            out global::System.DateTimeKind value,
            bool allowMatchingMetadataAttribute)
        {

            switch (name)
            {
                case string s when s.Equals(nameof(global::System.DateTimeKind.Unspecified), global::System.StringComparison.OrdinalIgnoreCase):
                    value = global::System.DateTimeKind.Unspecified;
                    return true;
                case string s when s.Equals(nameof(global::System.DateTimeKind.Utc), global::System.StringComparison.OrdinalIgnoreCase):
                    value = global::System.DateTimeKind.Utc;
                    return true;
                case string s when s.Equals(nameof(global::System.DateTimeKind.Local), global::System.StringComparison.OrdinalIgnoreCase):
                    value = global::System.DateTimeKind.Local;
                    return true;
                case string s when int.TryParse(name, out var val):
                    value = (global::System.DateTimeKind)val;
                    return true;
                default:
                    value = default;
                    return false;
            }
        }

        private static bool TryParseWithCase(
#if NETCOREAPP3_0_OR_GREATER
            [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)]
#endif
            string? name,
            out global::System.DateTimeKind value,
            bool allowMatchingMetadataAttribute)
        {

            switch (name)
            {
                case nameof(global::System.DateTimeKind.Unspecified):
                    value = global::System.DateTimeKind.Unspecified;
                    return true;
                case nameof(global::System.DateTimeKind.Utc):
                    value = global::System.DateTimeKind.Utc;
                    return true;
                case nameof(global::System.DateTimeKind.Local):
                    value = global::System.DateTimeKind.Local;
                    return true;
                case string s when int.TryParse(name, out var val):
                    value = (global::System.DateTimeKind)val;
                    return true;
                default:
                    value = default;
                    return false;
            }
        }

#if NETCOREAPP && !NETCOREAPP2_0 && !NETCOREAPP1_1 && !NETCOREAPP1_0
        /// <summary>
        /// Converts the string representation of the name or numeric value of
        /// an <see cref="global::System.DateTimeKind" /> to the equivalent instance.
        /// </summary>
        /// <param name="name">The case-sensitive string representation of the enumeration name or underlying value to convert</param>
        /// <returns>An object of type <see cref="global::System.DateTimeKind" /> whose
        /// value is represented by <paramref name="name"/></returns>
        public static global::System.DateTimeKind Parse(
#if NETCOREAPP3_0_OR_GREATER
            [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)]
#endif
            in global::System.ReadOnlySpan<char> name)
                => TryParse(name, out var value, false, false) ? value : ThrowValueNotFound(name.ToString());

        /// <summary>
        /// Converts the string representation of the name or numeric value of
        /// an <see cref="global::System.DateTimeKind" /> to the equivalent instance.
        /// </summary>
        /// <param name="name">The case-sensitive string representation of the enumeration name or underlying value to convert</param>
        /// <param name="ignoreCase"><c>true</c> to read value in case insensitive mode; <c>false</c> to read value in case sensitive mode.</param>
        /// <returns>An object of type <see cref="global::System.DateTimeKind" /> whose
        /// value is represented by <paramref name="name"/></returns>
        public static global::System.DateTimeKind Parse(
#if NETCOREAPP3_0_OR_GREATER
            [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)]
#endif
            in global::System.ReadOnlySpan<char> name,
            bool ignoreCase)
                => TryParse(name, out var value, ignoreCase, false) ? value : ThrowValueNotFound(name.ToString());

        /// <summary>
        /// Converts the string representation of the name or numeric value of
        /// an <see cref="global::System.DateTimeKind" /> to the equivalent instance.
        /// </summary>
        /// <param name="name">The case-sensitive string representation of the enumeration name or underlying value to convert</param>
        /// <param name="ignoreCase"><c>true</c> to read value in case insensitive mode; <c>false</c> to read value in case sensitive mode.</param>
        /// <param name="allowMatchingMetadataAttribute">If <c>true</c>, considers the value included in metadata attributes such as
        /// <c>[Display]</c> attribute when parsing, otherwise only considers the member names.</param>
        /// <returns>An object of type <see cref="global::System.DateTimeKind" /> whose
        /// value is represented by <paramref name="name"/></returns>
        public static global::System.DateTimeKind Parse(
#if NETCOREAPP3_0_OR_GREATER
            [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)]
#endif
            in global::System.ReadOnlySpan<char> name,
            bool ignoreCase,
            bool allowMatchingMetadataAttribute)
                => TryParse(name, out var value, ignoreCase, allowMatchingMetadataAttribute) ? value : ThrowValueNotFound(name.ToString());

        /// <summary>
        /// Converts the span representation of the name or numeric value of
        /// an <see cref="global::System.DateTimeKind" /> to the equivalent instance.
        /// The return value indicates whether the conversion succeeded.
        /// </summary>
        /// <param name="name">The span representation of the enumeration name or underlying value to convert</param>
        /// <param name="value">When this method returns, contains an object of type 
        /// <see cref="global::System.DateTimeKind" /> whose
        /// value is represented by <paramref name="value"/> if the parse operation succeeds.
        /// If the parse operation fails, contains the default value of the underlying type
        /// of <see cref="global::System.DateTimeKind" />. This parameter is passed uninitialized.</param>
        /// <returns><c>true</c> if the value parameter was converted successfully; otherwise, <c>false</c>.</returns>
        public static bool TryParse(
#if NETCOREAPP3_0_OR_GREATER
            [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)]
#endif
            in global::System.ReadOnlySpan<char> name, 
            out global::System.DateTimeKind value)
            => TryParse(name, out value, false, false);

        /// <summary>
        /// Converts the span representation of the name or numeric value of
        /// an <see cref="global::System.DateTimeKind" /> to the equivalent instance.
        /// The return value indicates whether the conversion succeeded.
        /// </summary>
        /// <param name="name">The span representation of the enumeration name or underlying value to convert</param>
        /// <param name="value">When this method returns, contains an object of type 
        /// <see cref="global::System.DateTimeKind" /> whose
        /// value is represented by <paramref name="value"/> if the parse operation succeeds.
        /// If the parse operation fails, contains the default value of the underlying type
        /// of <see cref="global::System.DateTimeKind" />. This parameter is passed uninitialized.</param>
        /// <param name="ignoreCase"><c>true</c> to read value in case insensitive mode; <c>false</c> to read value in case sensitive mode.</param>
        /// <returns><c>true</c> if the value parameter was converted successfully; otherwise, <c>false</c>.</returns>
        public static bool TryParse(
#if NETCOREAPP3_0_OR_GREATER
            [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)]
#endif
            in global::System.ReadOnlySpan<char> name,
            out global::System.DateTimeKind value,
            bool ignoreCase)
            => TryParse(name, out value, ignoreCase, false);

        /// <summary>
        /// Converts the span representation of the name or numeric value of
        /// an <see cref="global::System.DateTimeKind" /> to the equivalent instance.
        /// The return value indicates whether the conversion succeeded.
        /// </summary>
        /// <param name="name">The span representation of the enumeration name or underlying value to convert</param>
        /// <param name="result">When this method returns, contains an object of type 
        /// <see cref="global::System.DateTimeKind" /> whose
        /// value is represented by <paramref name="result"/> if the parse operation succeeds.
        /// If the parse operation fails, contains the default value of the underlying type
        /// of <see cref="global::System.DateTimeKind" />. This parameter is passed uninitialized.</param>
        /// <param name="ignoreCase"><c>true</c> to read value in case insensitive mode; <c>false</c> to read value in case sensitive mode.</param>
        /// <param name="allowMatchingMetadataAttribute">If <c>true</c>, considers the value included in metadata attributes such as
        /// <c>[Display]</c> attribute when parsing, otherwise only considers the member names.</param>
        /// <returns><c>true</c> if the value parameter was converted successfully; otherwise, <c>false</c>.</returns>
        public static bool TryParse(
#if NETCOREAPP3_0_OR_GREATER
            [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)]
#endif
            in global::System.ReadOnlySpan<char> name,
            out global::System.DateTimeKind result,
            bool ignoreCase,
            bool allowMatchingMetadataAttribute)
                => ignoreCase
                    ? TryParseIgnoreCase(in name, out result, allowMatchingMetadataAttribute)
                    : TryParseWithCase(in name, out result, allowMatchingMetadataAttribute);

        private static bool TryParseIgnoreCase(
#if NETCOREAPP3_0_OR_GREATER
            [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)]
#endif
            in global::System.ReadOnlySpan<char> name,
            out global::System.DateTimeKind result,
            bool allowMatchingMetadataAttribute)
        {
            switch (name)
            {
                case global::System.ReadOnlySpan<char> current when global::System.MemoryExtensions.Equals(current, nameof(global::System.DateTimeKind.Unspecified), global::System.StringComparison.OrdinalIgnoreCase):
                    result = global::System.DateTimeKind.Unspecified;
                    return true;
                case global::System.ReadOnlySpan<char> current when global::System.MemoryExtensions.Equals(current, nameof(global::System.DateTimeKind.Utc), global::System.StringComparison.OrdinalIgnoreCase):
                    result = global::System.DateTimeKind.Utc;
                    return true;
                case global::System.ReadOnlySpan<char> current when global::System.MemoryExtensions.Equals(current, nameof(global::System.DateTimeKind.Local), global::System.StringComparison.OrdinalIgnoreCase):
                    result = global::System.DateTimeKind.Local;
                    return true;
                case global::System.ReadOnlySpan<char> current when int.TryParse(name, out var numericResult):
                    result = (global::System.DateTimeKind)numericResult;
                    return true;
                default:
                    result = default;
                    return false;
            }
        }

        private static bool TryParseWithCase(
#if NETCOREAPP3_0_OR_GREATER
            [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)]
#endif
            in global::System.ReadOnlySpan<char> name,
            out global::System.DateTimeKind result,
            bool allowMatchingMetadataAttribute)
        {
            switch (name)
            {
                case global::System.ReadOnlySpan<char> current when global::System.MemoryExtensions.Equals(current, nameof(global::System.DateTimeKind.Unspecified), global::System.StringComparison.Ordinal):
                    result = global::System.DateTimeKind.Unspecified;
                    return true;
                case global::System.ReadOnlySpan<char> current when global::System.MemoryExtensions.Equals(current, nameof(global::System.DateTimeKind.Utc), global::System.StringComparison.Ordinal):
                    result = global::System.DateTimeKind.Utc;
                    return true;
                case global::System.ReadOnlySpan<char> current when global::System.MemoryExtensions.Equals(current, nameof(global::System.DateTimeKind.Local), global::System.StringComparison.Ordinal):
                    result = global::System.DateTimeKind.Local;
                    return true;
                case global::System.ReadOnlySpan<char> current when int.TryParse(name, out var numericResult):
                    result = (global::System.DateTimeKind)numericResult;
                    return true;
                default:
                    result = default;
                    return false;
            }
        }
#endif

        /// <summary>
        /// Cast a value of <see cref="global::System.DateTimeKind" /> to the underlying type (<c>int</c>).
        /// This is mainly a convenience method.
        /// </summary>
        /// <returns>The value of <see cref="global::System.DateTimeKind" /> cast to the underlying type.</returns>
        public static int AsUnderlyingType(this global::System.DateTimeKind value)
        {
            return (int) value;
        }

        /// <summary>
        /// Retrieves an array of the values of the members defined in
        /// <see cref="global::System.DateTimeKind" />.
        /// Note that this returns a new array with every invocation, so
        /// should be cached if appropriate.
        /// </summary>
        /// <returns>An array of the values defined in <see cref="global::System.DateTimeKind" /></returns>
        public static global::System.DateTimeKind[] GetValues()
        {
            return new[]
            {
                global::System.DateTimeKind.Unspecified,
                global::System.DateTimeKind.Utc,
                global::System.DateTimeKind.Local,
            };
        }

        /// <summary>
        /// Retrieves an array of the underlying-values of the members defined in
        /// <see cref="global::System.DateTimeKind" />.
        /// Note that this returns a new array with every invocation, so
        /// should be cached if appropriate.
        /// </summary>
        /// <returns>An array of the underlying-values defined in <see cref="global::System.DateTimeKind" /></returns>
        public static int[] GetValuesAsUnderlyingType()
        {
            return new[]
            {
                (int) global::System.DateTimeKind.Unspecified,
                (int) global::System.DateTimeKind.Utc,
                (int) global::System.DateTimeKind.Local,
            };
        }

        /// <summary>
        /// Retrieves an array of the names of the members defined in
        /// <see cref="global::System.DateTimeKind" />.
        /// Note that this returns a new array with every invocation, so
        /// should be cached if appropriate.
        /// </summary>
        /// <returns>An array of the names of the members defined in <see cref="global::System.DateTimeKind" /></returns>
        public static string[] GetNames()
        {
            return new[]
            {
                nameof(global::System.DateTimeKind.Unspecified),
                nameof(global::System.DateTimeKind.Utc),
                nameof(global::System.DateTimeKind.Local),
            };
        }
    }
#pragma warning restore CS0612 // Ignore usages of obsolete members or enums
#pragma warning restore CS0618 // Ignore usages of obsolete members or enums
}
  
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by the NetEscapades.EnumGenerators.Interceptors source generator
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

#nullable enable

#if NETESCAPADES_ENUMGENERATORS_EMBED_ATTRIBUTES
namespace NetEscapades.EnumGenerators
{
    /// <summary>
    /// Add to an assembly to indicate that usages of the enum should
    /// be automatically intercepted to use the extension methods
    /// generated by EnumExtensionsAttribute in this project.
    /// Note that the extension methods must be accessible from this project,
    /// otherwise you will receive compilation errors
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Assembly, AllowMultiple = true)]
    [global::System.Diagnostics.Conditional("NETESCAPADES_ENUMGENERATORS_USAGES")]
#if NET5_0_OR_GREATER
    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage(Justification = "Generated by the NetEscapades.EnumGenerators.Interceptors source generator.")]
#else
    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
#endif
    public class InterceptableAttribute<T> : global::System.Attribute
        where T: global::System.Enum
    {
        /// <summary>
        /// The namespace generated for the extension class. If not provided,
        /// and the referenced enum is in a different project, the namespace
        /// of the extension methods are assumed to be the same as the enum.
        /// </summary>
        public string? ExtensionClassNamespace { get; set; }
        
        /// <summary>
        /// The name used for the extension class. If not provided,
        /// and the referenced enum is in a different project, the enum name
        /// with an <c>Extensions</c> suffix will be assumed. For example for
        /// an Enum called StatusCodes, the assumed name will be StatusCodesExtensions.
        /// </summary>
        public string? ExtensionClassName { get; set; }
    }
}
#endif
  
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by the NetEscapades.EnumGenerators.Interceptors source generator
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

#nullable enable
namespace System.Runtime.CompilerServices
{
    // this type is needed by the compiler to implement interceptors - it doesn't need to
    // come from the runtime itself, though

    [global::System.Diagnostics.Conditional("DEBUG")] // not needed post-build, so: evaporate
    [global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple = true)]
    sealed file class InterceptsLocationAttribute : global::System.Attribute
    {
        public InterceptsLocationAttribute(int version, string data)
        {
            _ = version;
            _ = data;
        }
    }
}

#pragma warning disable CS0612 // Ignore usages of obsolete members or enums
#pragma warning disable CS0618 // Ignore usages of obsolete members or enums
namespace NetEscapades.EnumGenerators
{
    static file class EnumInterceptors
    {
        [global::System.Runtime.CompilerServices.InterceptsLocation(123, "REDACTED")] // Program.cs(16,32)
        [global::System.Runtime.CompilerServices.InterceptsLocation(123, "REDACTED")] // Program.cs(17,49)
        [global::System.Runtime.CompilerServices.InterceptsLocation(123, "REDACTED")] // Program.cs(18,33)
        [global::System.Runtime.CompilerServices.InterceptsLocation(123, "REDACTED")] // Program.cs(19,31)
        [global::System.Runtime.CompilerServices.InterceptsLocation(123, "REDACTED")] // Program.cs(26,38)
        public static string StringComparisonExtensionsToString(this global::System.Enum value)
            => global::System.StringComparisonExtensions.ToStringFast((global::System.StringComparison)value);

    }
}
#pragma warning restore CS0612 // Ignore usages of obsolete members or enums
#pragma warning restore CS0618 // Ignore usages of obsolete members or enums

]